# Azure DevOps Pipeline: Automated Python Dependency Updates via uv
# Scans GitHub Advanced Security alerts and raises PR with updated dependencies
#
# Prerequisites:
# - GitHub Advanced Security enabled on repository
# - uv installed or available via pip
# - PAT with repo write + PR creation permissions stored in variable group

trigger: none

schedules:
  - cron: '0 6 * * 1'  # Weekly on Monday at 6 AM UTC
    displayName: 'Weekly Security Scan'
    branches:
      include:
        - main
    always: true

pr: none

parameters:
  - name: dryRun
    displayName: 'Dry Run (no PR created)'
    type: boolean
    default: false
  - name: targetBranch
    displayName: 'Target branch for PR'
    type: string
    default: 'main'

variables:
  - name: pythonVersion
    value: '3.11'
  - name: updateBranchName
    value: 'automated/security-dependency-update-$(Build.BuildId)'

pool:
  vmImage: 'ubuntu-latest'

stages:
  - stage: ScanAndUpdate
    displayName: 'Scan Security Alerts & Update Dependencies'
    jobs:
      - job: CheckAlerts
        displayName: 'Check for Vulnerable Dependencies'
        steps:
          - checkout: self
            persistCredentials: true
            fetchDepth: 0

          - task: UsePythonVersion@0
            displayName: 'Use Python $(pythonVersion)'
            inputs:
              versionSpec: '$(pythonVersion)'

          - script: |
              pip install uv --quiet
              uv --version
            displayName: 'Install uv'

          - script: |
              set -e
              
              echo "Fetching Advanced Security dependency alerts..."
              
              # Get organization and project from predefined variables
              ORG_URL=$(echo "$(System.CollectionUri)" | sed 's:/*$::')
              PROJECT="$(System.TeamProject)"
              REPO_ID="$(Build.Repository.ID)"
              
              # Fetch dependency alerts from Advanced Security API
              ALERTS_RESPONSE=$(curl -s -X GET \
                -H "Authorization: Bearer $(System.AccessToken)" \
                -H "Content-Type: application/json" \
                "${ORG_URL}/${PROJECT}/_apis/alert/repositories/${REPO_ID}/alerts?api-version=7.2-preview.1&criteria.alertType=dependency&criteria.states=active")
              
              echo "$ALERTS_RESPONSE" > alerts_raw.json
              
              # Parse and extract vulnerable packages
              python3 << 'EOF'
              import json
              import sys
              
              with open("alerts_raw.json") as f:
                  data = json.load(f)
              
              alerts = data.get("value", [])
              
              if not alerts:
                  print("No active dependency alerts found")
                  print("##vso[task.setvariable variable=hasVulnerabilities;isOutput=true]false")
                  print("##vso[task.setvariable variable=vulnCount;isOutput=true]0")
                  sys.exit(0)
              
              vulnerabilities = []
              for alert in alerts:
                  # Extract package info from the alert
                  logical_locations = alert.get("logicalLocations", [])
                  
                  pkg_name = None
                  pkg_version = None
                  
                  for loc in logical_locations:
                      if loc.get("kind") == "package":
                          full_name = loc.get("fullyQualifiedName", "")
                          # Format is typically "package@version" or "ecosystem/package@version"
                          if "@" in full_name:
                              parts = full_name.rsplit("@", 1)
                              pkg_name = parts[0].split("/")[-1]  # Remove ecosystem prefix if present
                              pkg_version = parts[1] if len(parts) > 1 else None
                          else:
                              pkg_name = full_name.split("/")[-1]
                  
                  if not pkg_name:
                      # Try getting from tools/dependency
                      tools = alert.get("tools", [])
                      for tool in tools:
                          rules = tool.get("rules", [])
                          for rule in rules:
                              pkg_name = rule.get("name", "").split("/")[-1]
                              break
                  
                  if pkg_name:
                      vuln_info = {
                          "name": pkg_name,
                          "version": pkg_version,
                          "alert_id": alert.get("alertId"),
                          "severity": alert.get("severity", "unknown"),
                          "title": alert.get("title", ""),
                          "cve": None,
                          "fix_versions": []
                      }
                      
                      # Extract CVE if available
                      tools = alert.get("tools", [])
                      for tool in tools:
                          for rule in tool.get("rules", []):
                              rule_id = rule.get("id", "")
                              if rule_id.startswith("CVE-"):
                                  vuln_info["cve"] = rule_id
                              # Check for fix version in rule description
                              desc = rule.get("fullDescription", {}).get("text", "")
                              if "fixed in" in desc.lower():
                                  # Try to extract fix version
                                  pass
                      
                      vulnerabilities.append(vuln_info)
              
              # Deduplicate by package name
              unique_vulns = {}
              for v in vulnerabilities:
                  name = v["name"]
                  if name not in unique_vulns:
                      unique_vulns[name] = v
                  else:
                      # Merge CVEs if multiple alerts for same package
                      if v.get("cve") and not unique_vulns[name].get("cve"):
                          unique_vulns[name]["cve"] = v["cve"]
              
              vuln_list = list(unique_vulns.values())
              
              print(f"\nFound {len(vuln_list)} vulnerable package(s) from Advanced Security:")
              for v in vuln_list:
                  cve = v.get("cve") or "N/A"
                  print(f"  - {v['name']}@{v.get('version', '?')} [{v['severity']}] {cve}")
              
              # Save for next step
              with open("vulnerable_packages.json", "w") as f:
                  json.dump(vuln_list, f, indent=2)
              
              print(f"\n##vso[task.setvariable variable=hasVulnerabilities;isOutput=true]true")
              print(f"##vso[task.setvariable variable=vulnCount;isOutput=true]{len(vuln_list)}")
              EOF
            name: scanAlerts
            displayName: 'Fetch Advanced Security Dependency Alerts'
            env:
              SYSTEM_ACCESSTOKEN: $(System.AccessToken)

          - script: |
              cat > update_deps.py << 'EOF'
              #!/usr/bin/env python3
              """
              Update vulnerable dependencies using uv.
              """
              import json
              import subprocess
              import sys
              from pathlib import Path

              def update_with_uv(packages: list[str]):
                  """Update packages using uv."""
                  req_files = list(Path(".").glob("**/requirements*.txt"))
                  pyproject = Path("pyproject.toml")
                  uv_lock = Path("uv.lock")
                  
                  updated = []
                  
                  # If using uv with pyproject.toml
                  if pyproject.exists():
                      print("Detected pyproject.toml - using uv lock/sync")
                      
                      for pkg in packages:
                          print(f"Upgrading {pkg}...")
                          result = subprocess.run(
                              ["uv", "lock", "--upgrade-package", pkg],
                              capture_output=True,
                              text=True
                          )
                          if result.returncode == 0:
                              updated.append(pkg)
                              print(f"  âœ“ {pkg} upgraded")
                          else:
                              print(f"  âœ— Failed to upgrade {pkg}: {result.stderr}")
                      
                      # Sync to ensure consistency
                      subprocess.run(["uv", "sync"], capture_output=True)
                  
                  # For requirements.txt files
                  for req_file in req_files:
                      print(f"\nProcessing {req_file}...")
                      
                      # Read current requirements
                      content = req_file.read_text()
                      lines = content.splitlines()
                      new_lines = []
                      
                      for line in lines:
                          line_lower = line.lower().strip()
                          pkg_updated = False
                          
                          for pkg in packages:
                              if line_lower.startswith(pkg.lower()) or f"/{pkg.lower()}" in line_lower:
                                  # Get latest version using uv
                                  result = subprocess.run(
                                      ["uv", "pip", "compile", "--quiet", "-"],
                                      input=pkg,
                                      capture_output=True,
                                      text=True
                                  )
                                  if result.returncode == 0 and result.stdout.strip():
                                      new_line = result.stdout.strip().split('\n')[0]
                                      new_lines.append(new_line)
                                      updated.append(pkg)
                                      print(f"  âœ“ {line.strip()} -> {new_line}")
                                      pkg_updated = True
                                      break
                          
                          if not pkg_updated:
                              new_lines.append(line)
                      
                      # Write updated requirements
                      req_file.write_text('\n'.join(new_lines) + '\n')
                  
                  return list(set(updated))

              def main():
                  vuln_file = Path("vulnerable_packages.json")
                  if not vuln_file.exists():
                      print("No vulnerable packages file found")
                      return 0
                  
                  with open(vuln_file) as f:
                      vulnerabilities = json.load(f)
                  
                  if not vulnerabilities:
                      print("No vulnerabilities to fix")
                      return 0
                  
                  packages = [v.get("name") for v in vulnerabilities if v.get("name")]
                  print(f"Attempting to update {len(packages)} package(s): {', '.join(packages)}")
                  
                  updated = update_with_uv(packages)
                  
                  print(f"\n{'='*50}")
                  print(f"Successfully updated: {len(updated)} package(s)")
                  
                  if updated:
                      # Write summary for PR description
                      with open("update_summary.md", "w") as f:
                          f.write("## Security Dependency Updates\n\n")
                          f.write("This PR was automatically generated to address **Azure DevOps Advanced Security** alerts.\n\n")
                          f.write("### Updated Packages\n\n")
                          for pkg in updated:
                              vuln = next((v for v in vulnerabilities if v.get("name") == pkg), {})
                              cve = vuln.get("cve") or "Security advisory"
                              severity = vuln.get("severity", "unknown")
                              alert_id = vuln.get("alert_id", "")
                              f.write(f"- **{pkg}** ({severity}): {cve}")
                              if alert_id:
                                  f.write(f" - Alert #{alert_id}")
                              f.write("\n")
                          f.write("\n### Actions Required\n\n")
                          f.write("1. Review the dependency changes\n")
                          f.write("2. Run tests to ensure compatibility\n")
                          f.write("3. Merge to resolve the security alerts\n")
                      
                      print("##vso[task.setvariable variable=hasUpdates;isOutput=true]true")
                  else:
                      print("##vso[task.setvariable variable=hasUpdates;isOutput=true]false")
                  
                  return 0

              if __name__ == "__main__":
                  sys.exit(main())
              EOF
              python update_deps.py
            name: updateDeps
            displayName: 'Update Vulnerable Dependencies'
            condition: eq(variables['scanAlerts.hasVulnerabilities'], 'true')

          - script: |
              set -e
              
              # Check if there are any changes
              if [ -z "$(git status --porcelain)" ]; then
                echo "No changes detected"
                echo "##vso[task.setvariable variable=hasChanges]false"
                exit 0
              fi
              
              echo "Changes detected:"
              git status --porcelain
              git diff --stat
              
              echo "##vso[task.setvariable variable=hasChanges]true"
            displayName: 'Check for Changes'
            condition: eq(variables['updateDeps.hasUpdates'], 'true')

          - script: |
              set -e
              
              # Configure git
              git config user.email "azure-pipelines@dev.azure.com"
              git config user.name "Azure Pipelines Security Bot"
              
              # Configure git to use System.AccessToken
              git remote set-url origin https://$(System.AccessToken)@dev.azure.com/$(System.CollectionUri)/$(System.TeamProject)/_git/$(Build.Repository.Name)
              
              # Create and checkout new branch
              git checkout -b $(updateBranchName)
              
              # Stage and commit changes
              git add -A
              git commit -m "fix(security): update vulnerable Python dependencies

              Automated security update via Azure DevOps pipeline.
              
              Updated packages based on pip-audit scan results.
              
              Pipeline: $(Build.BuildNumber)
              Build ID: $(Build.BuildId)"
              
              # Push branch using System.AccessToken
              git -c http.extraheader="Authorization: Bearer $(System.AccessToken)" push origin $(updateBranchName)
              
              echo "Branch $(updateBranchName) pushed successfully"
            displayName: 'Create and Push Branch'
            condition: and(eq(variables['hasChanges'], 'true'), eq('${{ parameters.dryRun }}', false))
            env:
              SYSTEM_ACCESSTOKEN: $(System.AccessToken)

          - script: |
              set -e
              
              # Read PR description
              PR_BODY=""
              if [ -f "update_summary.md" ]; then
                PR_BODY=$(cat update_summary.md)
              else
                PR_BODY="Automated security dependency update"
              fi
              
              # Create PR using Azure DevOps REST API
              PR_TITLE="fix(security): Update vulnerable Python dependencies"
              
              # Construct JSON payload
              PR_JSON=$(cat <<EOF
              {
                "sourceRefName": "refs/heads/$(updateBranchName)",
                "targetRefName": "refs/heads/${{ parameters.targetBranch }}",
                "title": "${PR_TITLE}",
                "description": "${PR_BODY//$'\n'/\\n}",
                "labels": [
                  {"name": "security"},
                  {"name": "automated"},
                  {"name": "dependencies"}
                ]
              }
              EOF
              )
              
              echo "Creating Pull Request..."
              
              # Use Azure DevOps CLI or REST API
              RESPONSE=$(curl -s -X POST \
                -H "Content-Type: application/json" \
                -H "Authorization: Bearer $(System.AccessToken)" \
                "$(System.CollectionUri)$(System.TeamProject)/_apis/git/repositories/$(Build.Repository.ID)/pullrequests?api-version=7.1" \
                -d "${PR_JSON}")
              
              PR_ID=$(echo "$RESPONSE" | python3 -c "import sys, json; print(json.load(sys.stdin).get('pullRequestId', 'unknown'))" 2>/dev/null || echo "unknown")
              
              if [ "$PR_ID" != "unknown" ] && [ -n "$PR_ID" ]; then
                echo "âœ“ Pull Request created successfully!"
                echo "  PR ID: $PR_ID"
                PR_URL="$(System.CollectionUri)$(System.TeamProject)/_git/$(Build.Repository.Name)/pullrequest/$PR_ID"
                echo "  URL: $PR_URL"
                echo "##vso[task.setvariable variable=prUrl]$PR_URL"
                echo "##vso[task.setvariable variable=prId]$PR_ID"
              else
                echo "Response: $RESPONSE"
                echo "##vso[task.logissue type=warning]PR creation may have failed. Check response above."
              fi
            displayName: 'Create Pull Request'
            condition: and(eq(variables['hasChanges'], 'true'), eq('${{ parameters.dryRun }}', false))
            env:
              SYSTEM_ACCESSTOKEN: $(System.AccessToken)

          - script: |
              echo "=================================="
              echo "       DRY RUN SUMMARY           "
              echo "=================================="
              echo ""
              echo "The following changes would be made:"
              echo ""
              git status --porcelain
              echo ""
              echo "Diff preview:"
              git diff --stat
              echo ""
              if [ -f "update_summary.md" ]; then
                echo "PR Description would be:"
                cat update_summary.md
              fi
              echo ""
              echo "No branch was pushed and no PR was created (dry run mode)"
            displayName: 'Dry Run Summary'
            condition: and(eq(variables['hasChanges'], 'true'), eq('${{ parameters.dryRun }}', true))

          - script: |
              echo "=================================="
              echo "       PIPELINE SUMMARY          "
              echo "=================================="
              echo ""
              echo "Vulnerabilities found: $(scanAlerts.vulnCount)"
              echo "Updates applied: $(updateDeps.hasUpdates)"
              echo "Changes committed: $(hasChanges)"
              echo ""
              if [ -n "$(prUrl)" ]; then
                echo "Pull Request: $(prUrl)"
              fi
            displayName: 'Pipeline Summary'
            condition: always()

  - stage: Notify
    displayName: 'Send Notifications'
    dependsOn: ScanAndUpdate
    condition: |
      and(
        succeeded(),
        ne(dependencies.ScanAndUpdate.outputs['CheckAlerts.scanAlerts.hasVulnerabilities'], 'false')
      )
    jobs:
      - job: SendNotification
        displayName: 'Send Teams/Slack Notification'
        steps:
          - script: |
              # Example: Send to Teams webhook (configure TEAMS_WEBHOOK_URL in variable group)
              if [ -n "$(TEAMS_WEBHOOK_URL)" ]; then
                curl -H "Content-Type: application/json" -d '{
                  "@type": "MessageCard",
                  "summary": "Security Dependency Update PR Created",
                  "themeColor": "FFA500",
                  "title": "ðŸ”’ Security Update PR Created",
                  "sections": [{
                    "facts": [
                      {"name": "Repository", "value": "$(Build.Repository.Name)"},
                      {"name": "Pipeline", "value": "$(Build.BuildNumber)"},
                      {"name": "Branch", "value": "$(updateBranchName)"}
                    ]
                  }]
                }' "$(TEAMS_WEBHOOK_URL)" || true
              fi
              
              echo "Notification step completed"
            displayName: 'Send Notification'
            condition: always()
